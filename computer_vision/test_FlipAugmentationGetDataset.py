# ********RoostGPT********
"""
Test generated by RoostGPT for test MiniProjects using AI Type  and AI Model 

ROOST_METHOD_HASH=get_dataset_fd4f3dcae8
ROOST_METHOD_SIG_HASH=get_dataset_b2a4fcf575


Scenario 1: All label files have corresponding image files
Details:
  TestName: test_all_labels_have_corresponding_images
  Description: Verify if the function correctly pairs each label file with its corresponding image file.
Execution:
  Arrange: Create a set of label files and corresponding image files in the specified directories.
  Act: Invoke the get_dataset function with the paths to the label and image directories.
  Assert: Check that the returned lists of image paths and labels are correctly paired and of equal length.
Validation:
  Ensuring that each label has a corresponding image file is crucial for applications like training machine learning models, where each input (image) needs an associated target (label).

Scenario 2: Some label files do not have corresponding image files
Details:
  TestName: test_missing_corresponding_images
  Description: Ensure the function handles the case where some label files do not have matching image files.
Execution:
  Arrange: Create a set of label files where some do not have corresponding image files.
  Act: Invoke the get_dataset function with the paths to the label and image directories.
  Assert: Check that the returned list of image paths only includes paths for labels with corresponding image files.
Validation:
  It is important to validate that the function does not return paths or labels for non-existent image files, which could lead to errors in downstream processes.

Scenario 3: Label files with no bounding boxes
Details:
  TestName: test_label_files_with_no_bounding_boxes
  Description: Verify that label files with no bounding boxes (empty or only containing whitespace) are skipped.
Execution:
  Arrange: Create a set of label files where some contain no bounding box information.
  Act: Invoke the get_dataset function with the paths to the label and image directories.
  Assert: Check that the returned lists exclude the entries related to the label files with no bounding boxes.
Validation:
  Skipping label files without bounding boxes is necessary because they provide no information for training or testing in object detection tasks.

Scenario 4: Label files with invalid bounding box values
Details:
  TestName: test_label_files_with_invalid_bounding_box_values
  Description: Ensure that the function gracefully handles label files with invalid bounding box values.
Execution:
  Arrange: Create a set of label files with some containing invalid bounding box values (e.g., non-numeric, out-of-range).
  Act: Invoke the get_dataset function, expecting it to handle invalid values without crashing.
  Assert: Check that the function returns the correct image paths and labels, excluding the ones with invalid values.
Validation:
  Handling invalid bounding box values is important to maintain the integrity of the dataset and prevent errors in subsequent processing steps.

Scenario 5: Non-existent directories
Details:
  TestName: test_non_existent_directories
  Description: Verify that the function handles non-existent directories gracefully.
Execution:
  Arrange: Use non-existent paths for the label and image directories.
  Act: Invoke the get_dataset function with the non-existent directory paths.
  Assert: Check that the function returns empty lists or raises an appropriate exception.
Validation:
  The function should handle non-existent directories without causing unhandled exceptions, ensuring robustness in the face of incorrect setup or input paths.

Scenario 6: Directory paths with no label files
Details:
  TestName: test_directories_with_no_label_files
  Description: Check the function's behavior when the label directory contains no label files.
Execution:
  Arrange: Provide a label directory path that contains no "*.txt" files.
  Act: Invoke the get_dataset function with the label and image directory paths.
  Assert: Check that the function returns empty lists for both image paths and labels.
Validation:
  It is important to confirm that the function can handle empty label directories, which could occur in real-world scenarios.

Scenario 7: Label files with varying line formats
Details:
  TestName: test_label_files_with_varying_line_formats
  Description: Ensure that the function can parse label files with varying line formats, including different whitespace characters and amounts.
Execution:
  Arrange: Create label files with varying line formats (e.g., tabs, multiple spaces, trailing spaces).
  Act: Invoke the get_dataset function with the label and image directory paths.
  Assert: Check that the function correctly parses all bounding box values regardless of line format variations.
Validation:
  Robust parsing of label files is necessary to accommodate variations in file formatting, which may arise from different annotation tools or manual editing.
"""

# ********RoostGPT********
import glob
import os
import random
from string import ascii_lowercase, digits
import cv2
import pytest
from computer_vision.flip_augmentation import get_dataset

class Test_FlipAugmentationGetDataset:

    @pytest.mark.valid
    @pytest.mark.regression
    def test_all_labels_have_corresponding_images(self, tmpdir):
        # Arrange
        label_dir = str(tmpdir.mkdir("labels"))
        img_dir = str(tmpdir.mkdir("images"))
        for i in range(5):
            label_name = f"label_{i}.txt"
            img_name = f"label_{i}.jpg"
            with open(os.path.join(label_dir, label_name), 'w') as label_file:
                label_file.write("0 0.1 0.1 0.2 0.2\n")
            with open(os.path.join(img_dir, img_name), 'wb') as img_file:
                img_file.write(os.urandom(1024))
        
        # Act
        img_paths, labels = get_dataset(label_dir, img_dir)
        
        # Assert
        assert len(img_paths) == len(labels) == 5
        for i in range(5):
            assert os.path.basename(img_paths[i]) == f"label_{i}.jpg"
            assert labels[i][0] == [0, 0.1, 0.1, 0.2, 0.2]

    @pytest.mark.invalid
    @pytest.mark.regression
    def test_missing_corresponding_images(self, tmpdir):
        # Arrange
        label_dir = str(tmpdir.mkdir("labels"))
        img_dir = str(tmpdir.mkdir("images"))
        for i in range(5):
            label_name = f"label_{i}.txt"
            with open(os.path.join(label_dir, label_name), 'w') as label_file:
                label_file.write("0 0.1 0.1 0.2 0.2\n")
            if i % 2 == 0:  # create image only for even indices
                img_name = f"label_{i}.jpg"
                with open(os.path.join(img_dir, img_name), 'wb') as img_file:
                    img_file.write(os.urandom(1024))

        # Act
        img_paths, labels = get_dataset(label_dir, img_dir)

        # Assert
        assert len(img_paths) == len(labels) == 3
        for i in range(0, 5, 2):
            assert os.path.basename(img_paths[i // 2]) == f"label_{i}.jpg"
            assert labels[i // 2][0] == [0, 0.1, 0.1, 0.2, 0.2]

    @pytest.mark.negative
    @pytest.mark.regression
    def test_label_files_with_no_bounding_boxes(self, tmpdir):
        # Arrange
        label_dir = str(tmpdir.mkdir("labels"))
        img_dir = str(tmpdir.mkdir("images"))
        for i in range(5):
            label_name = f"label_{i}.txt"
            img_name = f"label_{i}.jpg"
            with open(os.path.join(label_dir, label_name), 'w') as label_file:
                if i % 2 == 0:  # write content only for even indices
                    label_file.write("0 0.1 0.1 0.2 0.2\n")
            with open(os.path.join(img_dir, img_name), 'wb') as img_file:
                img_file.write(os.urandom(1024))

        # Act
        img_paths, labels = get_dataset(label_dir, img_dir)

        # Assert
        assert len(img_paths) == len(labels) == 3
        for i in range(0, 5, 2):
            assert os.path.basename(img_paths[i // 2]) == f"label_{i}.jpg"
            assert labels[i // 2][0] == [0, 0.1, 0.1, 0.2, 0.2]

    @pytest.mark.invalid
    @pytest.mark.regression
    def test_label_files_with_invalid_bounding_box_values(self, tmpdir):
        # Arrange
        label_dir = str(tmpdir.mkdir("labels"))
        img_dir = str(tmpdir.mkdir("images"))
        valid_labels = []
        for i in range(5):
            label_name = f"label_{i}.txt"
            img_name = f"label_{i}.jpg"
            with open(os.path.join(label_dir, label_name), 'w') as label_file:
                if i % 2 == 0:  # write valid content for even indices
                    label_content = "0 0.1 0.1 0.2 0.2\n"
                    valid_labels.append([0, 0.1, 0.1, 0.2, 0.2])
                else:
                    label_content = "invalid values\n"
                label_file.write(label_content)
            with open(os.path.join(img_dir, img_name), 'wb') as img_file:
                img_file.write(os.urandom(1024))

        # Act
        img_paths, labels = get_dataset(label_dir, img_dir)

        # Assert
        assert len(img_paths) == len(labels) == 3
        for i in range(len(valid_labels)):
            assert labels[i] == [valid_labels[i]]

    @pytest.mark.error
    @pytest.mark.regression
    def test_non_existent_directories(self):
        # Arrange
        label_dir = "non_existent_labels"
        img_dir = "non_existent_images"

        # Act & Assert
        with pytest.raises(FileNotFoundError):
            get_dataset(label_dir, img_dir)

    @pytest.mark.empty
    @pytest.mark.regression
    def test_directories_with_no_label_files(self, tmpdir):
        # Arrange
        label_dir = str(tmpdir.mkdir("empty_labels"))
        img_dir = str(tmpdir.mkdir("images"))
        for i in range(5):
            img_name = f"label_{i}.jpg"
            with open(os.path.join(img_dir, img_name), 'wb') as img_file:
                img_file.write(os.urandom(1024))

        # Act
        img_paths, labels = get_dataset(label_dir, img_dir)

        # Assert
        assert len(img_paths) == len(labels) == 0

    @pytest.mark.valid
    @pytest.mark.regression
    def test_label_files_with_varying_line_formats(self, tmpdir):
        # Arrange
        label_dir = str(tmpdir.mkdir("labels"))
        img_dir = str(tmpdir.mkdir("images"))
        for i in range(5):
            label_name = f"label_{i}.txt"
            img_name = f"label_{i}.jpg"
            with open(os.path.join(label_dir, label_name), 'w') as label_file:
                label_file.write("0\t0.1  0.1\t\t0.2   0.2  \n")
            with open(os.path.join(img_dir, img_name), 'wb') as img_file:
                img_file.write(os.urandom(1024))

        # Act
        img_paths, labels = get_dataset(label_dir, img_dir)

        # Assert
        assert len(img_paths) == len(labels) == 5
        for label in labels:
            assert label[0] == [0, 0.1, 0.1, 0.2, 0.2]
